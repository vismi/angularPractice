/**
 * otplib-core
 *
 * @author Gerald Yeo <contact@fusedthought.com>
 * @version: 6.0.3
 * @license: MIT
 **/
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, '__esModule', { value: true });

var otplibUtils = require('./utils');

function hotpCounter(counter) {
  var hexCounter = otplibUtils.intToHex(counter);
  return otplibUtils.leftPad(hexCounter, 16);
}

function hotpSecret(secret, options) {
  return new Buffer(secret, options.encoding);
}

function hotpDigest(secret, counter, options) {
  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object' || options == null) {
    throw new Error('Expecting options to be an object');
  }
  if (!options.crypto || typeof options.crypto.createHmac !== 'function') {
    throw new Error('Expecting options.crypto to have a createHmac function');
  }
  var createHmacSecret = options.createHmacSecret || hotpSecret;
  var hmacSecret = createHmacSecret(secret, options);
  var hexCounter = hotpCounter(counter);
  var cryptoHmac = options.crypto.createHmac(options.algorithm, hmacSecret);
  return cryptoHmac.update(new Buffer(hexCounter, 'hex')).digest('hex');
}

function hotpOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return _extends({
    algorithm: 'sha1',
    createHmacSecret: hotpSecret,
    crypto: null,
    digits: 6,
    encoding: 'ascii'
  }, options);
}

function hotpToken(secret, counter) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (counter == null) {
    return '';
  }
  var opt = hotpOptions(options);
  var hmac = hotpDigest(secret, counter, opt);
  var offset = otplibUtils.hexToInt(hmac.substr(hmac.length - 1));
  var truncatedHash = hmac.substr(offset * 2, 8);
  var sigbit0 = otplibUtils.hexToInt(truncatedHash) & otplibUtils.hexToInt('7fffffff');
  var token = sigbit0 % Math.pow(10, opt.digits);
  token = otplibUtils.leftPad(token, opt.digits);
  return token;
}

function hotpCheck(token, secret, counter) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  var systemToken = hotpToken(secret, counter, options);
  if (systemToken.length < 1) {
    return false;
  }
  return otplibUtils.isSameToken(token, systemToken);
}

function totpCounter(epoch, step) {
  return Math.floor(epoch / step / 1000);
}

function totpSecret(secret, options) {
  var encoded = new Buffer(secret, options.encoding);
  switch (options.algorithm.toLowerCase()) {
    case 'sha1':
      return otplibUtils.padSecret(encoded, 20);
    case 'sha256':
      return otplibUtils.padSecret(encoded, 32);
    case 'sha512':
      return otplibUtils.padSecret(encoded, 64);
    default:
      return encoded;
  }
}

var defaultOptions = {
  createHmacSecret: totpSecret,
  epoch: null,
  step: 30
};
function totpOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var opt = _extends(hotpOptions(), defaultOptions, options);
  opt.epoch = typeof opt.epoch === 'number' ? opt.epoch * 1000 : new Date().getTime();
  return opt;
}

function totpToken(secret) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var opt = totpOptions(options);
  var counter = totpCounter(opt.epoch, opt.step);
  return hotpToken(secret, counter, opt);
}

function totpCheck(token, secret) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var systemToken = totpToken(secret, options || {});
  if (systemToken.length < 1) {
    return false;
  }
  return otplibUtils.isSameToken(token, systemToken);
}

exports.hotpCheck = hotpCheck;
exports.hotpCounter = hotpCounter;
exports.hotpDigest = hotpDigest;
exports.hotpOptions = hotpOptions;
exports.hotpSecret = hotpSecret;
exports.hotpToken = hotpToken;
exports.totpCheck = totpCheck;
exports.totpCounter = totpCounter;
exports.totpOptions = totpOptions;
exports.totpSecret = totpSecret;
exports.totpToken = totpToken;